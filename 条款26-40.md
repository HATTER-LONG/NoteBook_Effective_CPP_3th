# Effective CPP

- [Effective CPP](#effective-cpp)
  - [实现 Implementations](#实现-implementations)
    - [条款 26：尽可能延后变量定义式的出现时间](#条款-26尽可能延后变量定义式的出现时间)
    - [条款 27：尽量少做转型动作](#条款-27尽量少做转型动作)
    - [条款 28：避免返回 handles 指向对象内部成分](#条款-28避免返回-handles-指向对象内部成分)
    - [条款 29：为“异常安全”而努力是值得的](#条款-29为异常安全而努力是值得的)
    - [条款 30：透彻了解 inlining 的里里外外](#条款-30透彻了解-inlining-的里里外外)
    - [条款 31：将文件间的编译依存关系降至最低](#条款-31将文件间的编译依存关系降至最低)
  - [继承于面向对象设计](#继承于面向对象设计)
    - [条款 32：确定你的 public 继承塑模出 is-a 关系](#条款-32确定你的-public-继承塑模出-is-a-关系)
    - [条款 33：避免遮掩继承而来的名称](#条款-33避免遮掩继承而来的名称)
    - [条款 34：区分接口继承和实现继承](#条款-34区分接口继承和实现继承)

## 实现 Implementations

### 条款 26：尽可能延后变量定义式的出现时间

- 只在需要的地方声明变量，防止无用的构造与析构。
- 条款 4 介绍的通过 default 构造一个对象后赋予其初值，比在构造时指定初值效率要差。因此尽可能在声明变量时指定初始值，跳过无意义的 default 构造。
- 对于循环中使用的局部变量定义应该放在循环外还是循环内：
  - 如果对象变量的一个赋值操作成本小于一组构造+析构成本那么就定义在循环外，反之放入循环内。

### 条款 27：尽量少做转型动作

- c++ 提供了 4 种新式的转型：
  - `const_cast<T>(expression)`：用来将对象的常量性移除。
  - `dynamic_cast<T>(expression)`：安全向下转型。
  - `reinterpret_cast<T>(expression)`：用来处理无关类型之间的转换。具体实现于与编译器有关，不具备移植性。
  - `static_cast<T>(expression)`：强迫隐式转换，类似 c 中的强转。

- 目前旧式转型依然合法，但是新式的转型更具有优势：
  - 新式转型可以很容易在代码中辨识出来，便于搜索和阅读。
  - 各转型动作的目标越细化，编译器就越可能帮助诊断错误运用。

- 函数型转型: `doSomeWork(const YourClass&);` 原型存在以下使用 `doSomeWork(YourClass(15)) == doSomeWork(static_cast<YourClass>(15))`，这两种情况是等效的。

- 有时当我们持有一个函数指针时，不要妄想通过知道对象内存布局来进行偏移实现某些操作，这对于不同编译器不同平台时不可移植的。

- 下边这种操作时错误的，它仅仅时作用在了强转产生的一个针对 this 指针父类资源的副本上。

```cpp
class Window { // base class

public:
    virtual void onResize() {... } // base onResize impl
    ...
};

class SpecialWindow : public Window { // derived class

public:
    virtual void onResize()
    {                                           // derived onResize impl;

        static_cast<Window>(*this).onResize();  // cast *this to Window,
                                                // then call its onResize;
                                                // this doesn't work!
        ...                                     // do SpecialWindow-
    }                                           // specific stuff
    ...
};
```

- dynamic_cast 转换慎用，**大部分的实现效率低下**（通过对 class 名称进行比对）。一般使用的情况都是在你想要将一个退化为基类的派生类指针，转换为派生类。

### 条款 28：避免返回 handles 指向对象内部成分

- 通常我们认为对象”内部“就是指它的成员变量，不对外公开的数据、使用的函数，因此当返回 handle 指向了这部分则会导致类的封装遭到破坏。

- 类方法返回`引用的方式`向外暴露对象内部成员时：
  - 首先会导致类成员的封装性降低，类成员的封装性最多只等于这个类方法的访问级别。
  - 并且当返回非 const 的引用，并且这个引用对象指向类成员时，调用者就可以直接修改掉对象类成员，而不用通过任何方法，导致封装被破坏。解决这个的问题则是将返回的类型限定为 const，避免使用者修改的危险。`相当于有限的放松了类成员的读权限`。

- 当返回指针、迭代器与引用存在的问题是一致的，破坏了类的封装性。

- 除了破坏类的封装性问题，返回 handle 指向类内部成分还存在更严重的问题即，空悬(dangling)。因此当使用指向类内部的 handle 时，必须注意对象的生命周期。

### 条款 29：为“异常安全”而努力是值得的

- 异常安全性即当有异常抛出时，函数会保证：
  - 不泄露任何资源；
  - 不允许数据被破坏：即已经被修改的成员或者状态当异常发生后，需要保证恢复到调用之前的状态。

- 异常安全函数提供以下三个保证之一：
  - 基本承诺：如果异常抛出，程序内的任何事物仍然保持在有效的状态下。但是当调用失败后无法确保当前函数处于哪种状态。
  - 强烈保证：如果异常抛出，程序的状态不会改变，即如果函数调用成功就是完全成功，失败就会回退到调用前的状态。
  - 不抛掷异常：承诺不抛出异常，能供完成承诺的功能。

- 实现强烈保证的异常安全：
  - 将堆内存资源、锁资源等等，通过智能指针以及资源管理类进行管理。
  - `不要为了标识某件事情发生而改变对象状态，除非那件事情真的发生了`。
    - 只有当已经具体事情执行完成后才进行修改标志事情的内部状态（计数器、标志位等等）相应操作。
  
- copy and swap 策略：对打算修改的对象进行拷贝，在其副本上进行修改，当所有操作成功后，再将修改的副本与元对象在一个不抛出异常的操作中进行置换（swap）。

```cpp
struct PMImpl {                         // PMImpl = "PrettyMenu

    std::tr1::shared_ptr<Image> bgImage; // Impl."; see below for

    int imageChanges;                   // why it's a struct  p132解释
};

class PrettyMenu {

    ····

private:
    Mutex mutex;

    std::tr1::shared_ptr<PMImpl> pImpl;
};

void PrettyMenu::changeBackground(std::istream& imgSrc)
{

    using std::swap;                        // see Item 25

    Lock ml(&mutex);                        // acquire the mutex

    std::tr1::shared_ptr<PMImpl>            // copy obj. data

        pNew(new PMImpl(*pImpl));

    pNew->bgImage.reset(new Image(imgSrc)); // modify the copy

    ++pNew->imageChanges;

    swap(pImpl, pNew);                      // swap the new

                                            // data into place

}                                           // release the mutex
```

- copy and swap 虽然对于对象状态的回退是个好办法，但是它并不能保证整个函数，尤其当函数内部调用了其他函数方法，那么就变成了木桶效应，整个函数的异常安全级别由最低的那个函数决定。

- 保证异常安全对于效率上的影响也是需要考虑的，有时刻意的提供强烈保证的异常安全导致的效率与复杂度对于其他人也是灾难的，因此效率、复杂度与将要提供的安全等级之间需要寻求平衡。

### 条款 30：透彻了解 inlining 的里里外外

- inline 函数不仅仅时免去了调用关系，还开放了编译器对代码的最优化能力。
- inline 函数的代价：目标码变大、降低 cache 命中率影响效率。
  - 但是换个角度说，如果 inline 函数的本体很小，那么编译器优化后的代码可能比针对函数调用所产生的代码更小，这就是向好的方向前进了。因此 inline 函数要尽量短小精悍。

- inline 函数通常置于头文件中由于 Inlining 大多发生在 C++ 程序的编译器，在进行替换时需要了解函数实现。Templates 通常置于头文件中也是相同原因，它一旦被使用编译器为了具现它需要了解其具体实现。

- 大部分编译器会拒绝复杂的函数（例如带有循环或递归）的函数 inlining，并且对于所有的虚函数都不会 inlining，这是因为虚函数是当运行期才决定调用哪个，而 inline 则是编译期进行替换因此编译器不知道该替换那个函数。因此一个表面上看似 inline 的函数是否真的 inlining，取决于你使用的编译器以及编译环境。

- 调用方式也会影响是否以 inlining 的方式调用：

```cpp
inline void f() {...}      // assume compilers are willing to inline calls to f
void (*pf)() = f;          // pf points to f

...

f();                      // this call will be inlined, because it's a "normal" call
pf();                     // this call probably won't be, because it's through
                          // a function pointer
```

- 构造函数与析构函数往往是 inlining 的糟糕候选人，即使是空的构造函数背后也有着很多工作大多由编译器实现，由编译器于编译期间产生并安插到你的程序中的代码，有时就放在你的构造和析构函数内。而这部分实现中可能会调用 base class 或者其他成员变量的构造，而这些调用均会影响编译器是否对此空白构造函数 inlining。

- 程序库中必须考虑 inline 函数所带来的耦合，一旦某个 inline 函数进行了修改，则所有用到这个函数的关联库都必须重新编译。

### 条款 31：将文件间的编译依存关系降至最低

- include 包括的头文件造成文件间的依赖关系。
- 使用前置声明注意的问题：
  - 不该声明标准程序库（类似 std::string 是一个模板实现 typedef 成为 string）。
  - 前置声明 class 编译器无法获取到对象的大小。

- 针对前置声明获取不到 class 大小的问题：
  - 可以将类分割为两部分，一个只提供接口，另一个负责具体实现该接口，这种设计就是 pimple idiom 也被成为 Handle class：

  ```cpp
    #include <string>                      // standard library components
                                           // shouldn't be forward-declared
    #include <memory>                      // for tr1::shared_ptr; see below

    class PersonImpl;                      // forward decl of Person impl. class
    class Date;                            // forward decls of classes used in
    class Address;                         // Person interface

    class Person {
    public:
        Person(const std::string& name, const Date& birthday,
                const Address& addr);

        std::string name() const;

        std::string birthDate() const;

        std::string address() const;
    ...
    private:                                     // ptr to implementation;

        std::tr1::shared_ptr<PersonImpl> pImpl;  // see Item 13 for info on

    };                                            // std::tr1::shared_ptr
  ```

  - 这种分离关键在于以 “声明的依存性” 替换 “定义的依存性”，这便是编译依存性最小化本质：现实中让头文件尽可能自我满足，如果做不到，则让它于其他文件内的声明式（非定义式）相依。
    - 如果使用 **引用** 或者 **指针** 可以完成任务，就不要使用 object 定义式。
    - 尽量以 class 声明式替换 class 定义式。
    - 为声明式和定义式提供不同的头文件。 

- 另一种 Handle class 的方法是令目标类成为一个 抽象基类，描述出接口通过派生具体实现，这种实现称为 Interface class。
  - 而使用时需要以抽象基类的指针或者引用来编写应用程序，这就需要一个构建方法工厂、组件等等用来得到 Handle。

- Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系，从而降低了文件间的编译依赖性。但同样的它也存在的一些缺点：
  - 在 Handle classes 身上，成员函数通过 implementation pointer 取得对象数据，为每一次的访问增加了一层间接层，而每一个对象消耗的内存数量必须增加 implementation pointer，并且 implementation pointer 需要初始化，指向一个动态分配得来的 implementation object，所以必须承受动态内存分配于释放带来的消耗以及 bad_alloc 的异常可能。
  - 置于 Interface classes，由于每个函数都是 virtual，所以你必须为每次函数调用付出一个间接跳跃，此外还要承受 vptr（条款 7）等虚函数所带来的成本。
  - 不论 Handle classes 和 Interface classes 都不能充分利用 inline 函数，因为 inline 的具体实现都需要放入头文件内，而这两种方式均为了隐藏具体实现而努力。

## 继承于面向对象设计

### 条款 32：确定你的 public 继承塑模出 is-a 关系

- public 继承中：基类体现出一般化，派生类体现出特殊化。
- 语言于事实上的差异可能令继承关系显得不伦不类，就像企鹅于鸟的关系。但是具体的实现还是要看功能，假如你只考虑鸟喙、爪子等等，那么就不用但系企鹅与鸟的基类是否要由 fly 啦。
- public 继承意味着 is-a 。适用于 base classes 上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。

### 条款 33：避免遮掩继承而来的名称

- 众所周知😄 C++ 作用域就近原则，内层遮掩外层。而在继承关系中，派生类的成员函数内指向基类中的成员时，编译器可以找到相应的成员，这是由于派生类作用域被嵌套在基类的作用域内，

![scope](pic/33_1_socpe.png)

```cpp
class Base {
private:

  int x;

public:

  virtual void mf1() = 0;

  virtual void mf2();

  void mf3();
  ...
};

class Derived: public Base {
public:

  virtual void mf1();

  void mf4();
  ...
};

```

- 而当我们重载了基类的方法后，mf3 注意仅仅重载了无参数版本：

```cpp
class Base {

private:

  int x;

public:

  virtual void mf1() = 0;

  virtual void mf1(int);

  virtual void mf2();

  void mf3();

  void mf3(double);

  ...

};

class Derived: public Base {

public:

  virtual void mf1();

  void mf3();

  void mf4();

  ...

};
```

- 而这时进行调用，这就体现出了从名称查找的观点。这和本条款一开始展示的道理相同，当时函数 someFunc 内的 double x 遮掩了 global 作用域内的 int x，如今 Derived 内的函数 mf3 遮掩了一个名为 mf3 但类型不同的 Base 函数：

```cpp
Derived d;

int x;

...

d.mf1();                   // fine, calls Derived::mf1

d.mf1(x);                  // error! Derived::mf1 hides Base::mf1  可以看到派生类遮掩了基类的其他多态方法

d.mf2();                   // fine, calls Base::mf2

d.mf3();                   // fine, calls Derived::mf3

d.mf3(x);                  // error! Derived::mf3 hides Base::mf3 非虚的也是一样
```

- 那么该如何使用基类的其他不同参数的同名方法呢，这就可以使用 using 来在派生类中探查到基类内指定名称的方法。

```cpp
class Derived: public Base {

public:

  using Base::mf1;       // make all things in Base named mf1 and mf3

  using Base::mf3;       // visible (and public) in Derived's scope


  virtual void mf1();

  void mf3();

  void mf4();

  ...

};
```

- 而如果派生类是通过 private 继承基类时，并且仅仅想要继承 mf1 哪个无参数的版本，这时 using 就不能用了，因为它会导致所有 mf1 的函数在派生类作用域可见，这时就要用到一个转交函数：

```cpp
class Base {

public:

  virtual void mf1() = 0;

  virtual void mf1(int);

  ...                                    // as before

};

class Derived: private Base {

public:

  virtual void mf1()                   // forwarding function; implicitly

  { Base::mf1(); }                     // inline (see Item 30)
  ...

};

...

Derived d;

int x;

d.mf1();                               // fine, calls Derived::mf1

d.mf1(x);                              // error! Base::mf1() is hidden
```

### 条款 34：区分接口继承和实现继承